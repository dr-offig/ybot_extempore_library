(sys:load-preload-check 'ybot_adt)
(define *xtmlib-ybot_adt-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/contrib/ybot/ybot_base.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/contrib/ybot/ybot_base.xtm" 'quiet))





;;;;;;;;;;; Pair stuff - extends libs/core/adt.xtm ;;;;;;;;;;;;;;;;

(bind-func first:[!a,Pair{!a,!b}*,!a]*
  (lambda (p a)
    (tset! p 0 a)))

(bind-func second:[!b,Pair{!a,!b}*,!b]*
  (lambda (q b)
    (tset! q 1 b)))



;;;; More generalised associative array with comparator - extends libs/core/adt.xtm ;;;

(bind-func hash_find:[Pair{!w,!v}*,List{Pair{!w,!v}*}*,!w,[bool,!w,!w]*]*
  (lambda (hash key cmp)
    (if (null? hash)
        (convert null)
        (if (cmp (first (car hash)) key)
            (car hash)
            (hash_find (cdr hash) key cmp)))))

(bind-func hash_get:[!v,List{Pair{!w,!v}*}*,!w,[bool,!w,!w]*]*
  (lambda (hash key cmp)
    (if (null? hash)
        (convert null)
        (if (cmp (first (car hash)) key)
            (second (car hash))
            (hash_get (cdr hash) key cmp)))))


(bind-func hash_add:[!v,List{Pair{!w,!v}*}*,!w,[bool,!w,!w]*]*
  (lambda (hash key value cmp)
    (if (null? hash)
        (convert null)
        (set! hash (append hash (list (Pair key value)))))
    value))




(bind-func hash_set:[!v,List{Pair{!w,!v}*}*,!w,!v,[bool,!w,!w]*]*
  "set (or overwrite) value for key in dict (returns the old value)"
  (lambda (hash key value cmp)
    (if (null? hash)
        (convert null)
        (if (cmp (first (car hash)) key)
            (let ((oldval (second (car hash))))
              (tset! (car hash) 1 value)
              oldval)
            (if (null? (cdr hash))
                (begin (append hash (list (Pair key value)))
                       (convert null))
                (hash_set (cdr hash) key value cmp))))))



;;;;;;;;;; FIFO ;;;;;;;;;;;
;; CharFIFO data type: data pointer, start, length, capacity, max_capacity, mutex
(bind-type CharFIFO <i8*,i64,i64,i64,i64,i8*> (constructor? . #f) (printer? . #f))
(bind-func CharFIFO:[CharFIFO*,i64,i64]*
  (lambda (capacity max_capacity)
    (let ((output:CharFIFO* (alloc))
          (data:i8* (halloc capacity))
          (mutex:i8* (mutex_create))) 
      (tset! output 0 data)
      (tset! output 1 0)
      (tset! output 2 0)
      (tset! output 3 capacity)
      (tset! output 4 max_capacity)
      (tset! output 5 mutex)
      output)))



(bind-func data:[i8*,CharFIFO*]* (lambda (q) (tref q 0)))
(bind-func data:[i8*,CharFIFO*,i8*]* (lambda (q value) (tset! q 0 value)))
(bind-func start:[i64,CharFIFO*]* (lambda (q) (tref q 1)))
(bind-func start:[i64,CharFIFO*,i64]* (lambda (q value) (tset! q 1 value)))
(bind-func size:[i64,CharFIFO*]* (lambda (q) (tref q 2)))
(bind-func size:[i64,CharFIFO*,i64]* (lambda (q value) (tset! q 2 value)))
(bind-func capacity:[i64,CharFIFO*]* (lambda (q) (tref q 3)))
(bind-func capacity:[i64,CharFIFO*,i64]* (lambda (q value) (tset! q 3 value)))

(bind-func CharFIFO_d:[void,CharFIFO*]*
  (lambda (q)
    (free (tref q 0))
    (mutex_destroy (tref q 5))
    void))


(bind-func lock:[void,CharFIFO*]*
  (lambda (q)
    (mutex_lock (tref q 5))
    void))

(bind-func trylock:[bool,CharFIFO*]*
  (lambda (q)
    (= 1:i32 (mutex_trylock (tref q 5)))))

(bind-func unlock:[void,CharFIFO*]*
  (lambda (q)
    (mutex_unlock (tref q 5))
    void))

(bind-func end:[i64,CharFIFO*]*
  (lambda (q)
    (modulo (+ (start q) (size q)) (capacity q))))


(bind-func peek:[i8,CharFIFO*,i64]*
  (lambda (q n)
    (pref (data q) (modulo (+ (start q) n) (capacity q)))))


(bind-func push:[void,CharFIFO*,i8]*
  (lambda (q val)
    (cond
     ((trylock q)
      ;(printf "Queue %p has size: %lld   and capacity:  %lld\n" q (size:[i64,CharFIFO*]* q) (capacity q))
      (cond
       ((< (size:[i64,CharFIFO*]* q) (capacity q))
        ;(colour_pencil "black") (printf "%c" val) (colour_pencil "white")
        (pset! (data q) (end q) val)
        (size:[i64,CharFIFO*,i64]* q (+ 1 (size:[i64,CharFIFO*]* q)))
        (unlock q)
        void)
       ((<= (* 2 (capacity q)) (tref q 4))
        (let* ((n:i64 (* 2 (capacity q)))
               (i:i64 0)
               (old_data:i8* (data q))
               (new_data:i8* (halloc n)))
          (dotimes (i n)
            (pset! new_data i (peek q i)))
          (data q new_data)
          (free old_data)
          (start q 0)
          (capacity q n)
          (unlock q)
          (printf "Expanding CharFIFO capacity to %lld\n" n)
          (push q val)
          void))
       (else
        (pset! (data q) (end q) val)
        (start:[i64,CharFIFO*,i64]* q (+ 1 (start:[i64,CharFIFO*]* q)))
        ;;(if (= 0 (modulo (start:[i64,CharFIFO*]* q) 1024)) (printf "Queue full, overwriting oldest data\n"))
        (unlock q)
        void)))
     (else
      (printf "Push failed due to locked FIFO\n")
      void))))


(bind-func pop:[i8,CharFIFO*,bool*]*
  (lambda (q success)
    (cond
     ((trylock q)
      (cond
       ((< 0 (size:[i64,CharFIFO*]* q))
        (let ((output:i8 (pref (data q) (start q))))
          (start q (modulo (+ 1 (start q)) (capacity q)))
          (size:[i64,CharFIFO*,i64]* q (- (size:[i64,CharFIFO*]* q) 1))
          (pset! success 0 #t)
          (unlock q)
          output))
     (else
      (pset! success 0 #f)
      (unlock q)
      ;(printf "\n-------- Queue Empty -------\n")
      0:i8)))
     (else
      (pset! success 0 #f)
      (printf "\nPop failed due to locked FIFO\n")
      0:i8))))



(bind-func print:[void,CharFIFO*]*
  (lambda (q)
    (cond
     ((trylock q)
      (printf "Queue %p   " q)
      (printout ">>  ")
      (doloop (i (size:[i64,CharFIFO*]* q))
        (printout (peek q (- (- (size:[i64,CharFIFO*]* q) 1) i)))
        (printout "  "))
      (println ">>")
      (unlock q))
     (else
      (printf "Print failed due to locked FIFO\n")
      void))))
      

;; (bind-func test_queue
;;   (lambda ()
;;     (let ((q (CharFIFO 4)) (empty:bool* (alloc)))
;;       (pset! empty 0 #f)
;;       (push q 65:i8) (push q 66:i8) (push q 67:i8) (push q 68:i8) (print q)
;;       (printf "Popped value %c\n" (pop q empty)) (print q)
;;       (printf "Popped value %c\n" (pop q empty)) (print q)
;;       (push q 69:i8) (push q 70:i8) (print q)
;;       (push q 0.7) (print q)
;;       void)))





(bind-func caar:[!a,List{!a}*]* (lambda (x) (car (car x))))
(bind-func cadr:[!a,List{!a}*]* (lambda (x) (car (cdr x))))
(bind-func caaar:[!a,List{!a}*]* (lambda (x) (car (car (car x)))))
(bind-func caadr:[!a,List{!a}*]* (lambda (x) (car (car (cdr x)))))
(bind-func caddr:[!a,List{!a}*]* (lambda (x) (car (cdr (cdr x)))))
(bind-func caaaar:[!a,List{!a}*]* (lambda (x) (car (car (car (car x))))))
(bind-func caaadr:[!a,List{!a}*]* (lambda (x) (car (car (car (cdr x))))))
(bind-func caaddr:[!a,List{!a}*]* (lambda (x) (car (car (cdr (cdr x))))))
(bind-func cadddr:[!a,List{!a}*]* (lambda (x) (car (cdr (cdr (cdr x))))))
(bind-func caddddr:[!a,List{!a}*]* (lambda (x) (car (cdr (cdr (cdr (cdr x)))))))




(define *xtmlib-ybot_adt-loaded* #t)
