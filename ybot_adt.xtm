;; Include guard
(if (and (defined? '*xtmlib-ybot-adt-loaded*) *xtmlib-ybot-adt-loaded*)
    (sys:load-escape "ybot_adt library already loaded"))
(define *xtmlib-ybot-adt-loaded* #f)

;; Dependencies
(if (not (defined? '*ybot-lib-dir*))
    (sys:load-escape "Set the *ybot-lib-dir* variable before loading this library"))
(sys:load (string-append *ybot-lib-dir* "/ybot_maths.xtm"))         

;; Other dependencies
(sys:load "libs/core/adt.xtm")


;;;;;;;;;;;; Stacks ;;;;;;;;;;;;;;;;;
;(bind-alias StringStack List{String*})


;;;;;;;;;;;;;; List Stuff ;;;;;;;;;;;;
;; (bind-macro (apply args)
;;             `(,(car args) ,@(cdr args))) 


;; (bind-func testapply:[i8*]*
;;   (lambda ()
;;     (let* ((lst:List{i8}* (String2ByteList (String "Hello Toby")))
;;            (data (zalloc 11)))
;;       (apply pfill! data lst)
;;       (printf "%s" data)
;;       data)))
      

;; (testapply)




;;;;;;;;;;;;;;; Modulo Arithmetic ;;;;;;;;;;;;
;; (bind-type Zp <i64,i64>)

;; (bind-func Zp_val:[i64,Zp*]*
;;   (lambda (this:Zp*)
;;     (tref this 0)))

;; (bind-func Zp_base:[i64,Zp*]*
;;   (lambda (this:Zp*)
;;     (tref this 1)))

;; (bind-func Zp_setVal:[i64,Zp*,i64]*
;;   (lambda (this:Zp* val:i64)
;;     (tset! this 0 (imod val (Zp_base this)))
;;     (Zp_val this)))

;; (bind-func Zp_setBase:[i64,Zp*,i64]*
;;   (lambda (this:Zp* base:i64)
;;     (tset! this 1 base)
;;     base))

;; (bind-func Zp_inc:[i64,Zp*]*
;;   (lambda (this:Zp*)
;;     (Zp_setVal this (+ (Zp_val this) 1))
;;     (Zp_val this)))

;; (bind-func Zp_add_Zp:[Zp*,Zp*,Zp*]*
;;   (lambda (a:Zp* b:Zp*)
;;     (Zp
;;      (imod
;;       (+ (Zp_val a) (Zp_val b))
;;       (Zp_base a))
;;      (Zp_base a))))

;; (bind-func Zp_add_i64:[Zp*,Zp*,i64]*
;;   (lambda (a:Zp* b:i64)
;;     (Zp
;;      (imod
;;       (+ (Zp_val a) b)
;;       (Zp_base a))
;;      (Zp_base a))))

;(bind-poly Zp_add Zp_add_Zp)
;(bind-poly Zp_add Zp_add_i64)


;;;;;;;;;;;;;;;; Loop Array ;;;;;;;;;;;;;
(bind-type LoopArray <!a,i64>) 

(bind-func lref:[!a,LoopArray:<!a,i64>*,i64]*
  (lambda (myArray index)
    (pref (tref myArray 0) (modulo index (tref myArray 1)))))

(bind-func lset:[void,LoopArray*,i64,!a]*
  (lambda (myArray index value)
    (pset! (tref myArray 0) (modulo index (tref myArray 1)) value)
    void))

;(bind-func loop_array_test:[void]*
;  (lambda ()
;    (let* ((data:float* (zalloc 8))
;           (anArray (LoopArray data 8))
;           (i:i64 0))
;      (pfill! data (dtof 0.0) (dtof 1.1) (dtof 2.2) (dtof 3.3) (dtof 4.4) (dtof 5.5) (dtof 6.6) (dtof 7.7))
;      (lset anArray 3 (dtof 3.9))
;      (dotimes (i 20)
;        (println (lref anArray i)))
;      void)))
    
;;;;;;;;;;;;;;;; Shift Array ;;;;;;;;;;;
(bind-type ShiftArray <LoopArray:<!a,i64>*,i64>)

(bind-func DelayLine:[ShiftArray:<LoopArray*,i64>*,i64]*
  (lambda (lngth:i64)
    (let* ((data:float* (zalloc lngth))
           (loopArray (LoopArray data lngth))
           (shiftArray (ShiftArray loopArray 0)))
      shiftArray)))

(bind-func sa_shift:[!a,ShiftArray*,!a]
  (lambda (shiftArray value)
    (let* ((loopArray (tref shiftArray 0))
           (lngth (tref loopArray 1))
           (offset (tref shiftArray 1))
           (output (lref loopArray offset)))
      (lset loopArray (- offset 1) value)
      (tset! shiftArray 1 (imod (+ offset 1) lngth))
      output)))

(bind-func sa_peek:[!a,ShiftArray*,i64]
  (lambda (shiftArray index)
      (let* ((loopArray (tref shiftArray 0))
           (lngth (tref loopArray 1))
           (offset (tref shiftArray 1)))
        (lref loopArray (+ offset index)))))
 
;(bind-func test_shift_array:[ShiftArray:<LoopArray*,i64>*,i64]*
;  (lambda (lngth:i64)
;    (let* ((data:float* (zalloc lngth))
;           (loopArray (LoopArray data lngth))
;           (shiftArray (ShiftArray loopArray 0))
;           (i:i64 0))
;      (dotimes (i 20)
;        (println (sa_shift shiftArray (i64tof i))))
;      shiftArray)))


;; Generic tree: data, parent, children (opaque i8* hiding List{YTree*}*)
(bind-type YTree <!a,YTree*,i8*>)

(bind-func YTree:[YTree*,!a,YTree*,List{YTree*}]*
  (lambda (data parent children)
    (let ((root:YTree* (alloc)))
      (tfill! root data parent (cast children i8*))
      root)))

(bind-func data:[!a,YTree*]* (lambda (tree:YTree*) (tref tree 0)))
(bind-func data:[!a,YTree*,!a]* (lambda (tree:YTree* data_in) (tset! tree 0 data_in)))
(bind-func parent:[YTree*,YTree*]* (lambda (tree:YTree*) (tref tree 1)))
(bind-func parent:[YTree*,YTree*,YTree*]* (lambda (tree:YTree* parent_in:YTree*) (tset! tree 1 parent_in)))
(bind-func children:[List{YTree*}*,YTree*]* (lambda (tree:YTree*) (cast (tref tree 2) List{YTree*}*)))
(bind-func children:[List{YTree*}*,YTree*,List{YTree*}*]* (lambda (tree:YTree* children_in:List{YTree*}*) (cast (tset! tag 2 (cast children_in i8*)) List{YTree*}*)))

(bind-func satisfies:[List{YTree*}*,YTree*,[bool,YTree*]*]*
  (lambda (root condition)
    (flatten
     (map
      (lambda (child)
        (if (condition child)
            (cons child (satisfies child condition))
            (satisfies child condition)))
      (children root)))))




;; (bind-func test_i64_ytree:[YTree:<i64,YTree*,YTree*,i64>*]*
;;   (lambda ()
;;     (let ((output (make_node 3)))
;;       output)))

;; (test_i64_ytree)

;; (bind-func make_node:[YTree:<!a,YTree*,YTree*,i64>*,!a]*
;;   (lambda (x:!a)
;;     (let ((output (YTree x null null 0)))
;;       (tset! output 1 output)
;;       output)))

;; (bind-func test_specialised_node:[YTree:<i64,YTree*,YTree*,i64>*,i64]*
;;   (lambda (x:i64)
;;     (make_node x)))


;; (bind-func make_node:[YTree:<!a,YTree*,YTree*,i64>*,!a]*
;;   (lambda (x:!a)
;;     (let ((output:YTree:<!a,YTree*,YTree*,i64>* (zalloc)))
;;       (tset! output 0 x)
;;       (tset! output 1 output)
;;       (tset! output 2 null)
;;       (tset! output 3 0)
;;       output)))

;; (bind-func make_node_i64:[YTree:<i64,YTree*,YTree*,i64>*,i64]*
;;   (lambda (x:i64)
;;     (make_node x)))

;; (bind-func make_node_i64:[YTree:<i64,YTree*,YTree*,i64>*,i64]*
;;   (lambda (x:i64)
;;     (let ((output:YTree:<i64,YTree*,YTree*,i64>* (zalloc)))
;;       (tset! output 0 x)
;;       (tset! output 1 output)
;;       (tset! output 2 null)
;;       (tset! output 3 0)
;;       output)))

;; (make_node_i64 4)

;; (bind-func test2_i64_ytree:[YTree:<i64,YTree*,YTree*,i64>*]*
;;   (lambda ()
;;     (let ((output (make_node 3)))
;;       output)))


;; (bind-func make_node_i64:[Tree:<i64,Tree*,Tree*,i64>*,i64]*
;;   (lambda (n:i64)
;;     (let ((output:Tree:<i64,Tree*,Tree*,i64>* (zalloc)))
;;       (tset! output 0 n)
;;       (tset! output 1 output)
;;       (tset! output 2 null)
;;       (tset! output 3 0))
;;     output))


;; (bind-func make_node_int:[Tree:<i64,Tree*,Tree*,i64>*]*
;;   (lambda ()
;;     (make_node 3)))

;; (bind-func test_o_rama:[Tree:<String*,Tree*,Tree*,i64>*,String*]*
;;   (lambda (str:String*)
;;     (make_node str)))

;; (bind-func make_scrabble_tree:[Tree:<String*,Tree*,Tree*,i64>*,i64]*
;;   (lambda (depth:i64)
;;     (let* ((x:i8* (let ((_x:i8* (zalloc 1))) (pset! _x 0 'a') _x))
;;            (root:String* (String 1 x))
;;            (output (make_node x)))
;;       output)))

      


(set! *xtmlib-ybot-adt-loaded* #t)
