(sys:load-preload-check 'ybot_midi)
(define *xtmlib-ybot_midi-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/contrib/ybot/ybot_adt.xtm")
 (sys:load "libs/external/portmidi.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/contrib/ybot/adt.xtm" 'quiet)
 (sys:load "libs/external/portmidi.xtm" 'quiet))



;; We want to model the concept of a 'MIDI Device'. Note that PortMIDI doesn't really
;; deal with devices, just with streams. We will bundle together streams according to
;; their name, so that hopefully all the streams (both input and output) that get bundled
;; together into a device correspond to a particular physical box that is plugged in.
;; Of course this get's confusing when MIDI devices are daisy chained via MIDI sockets
;; on the physical device, or via virtual connection in the computers underlying MIDI API.
;; It is entirely possible that these may be bundled together incorrectly. You can however
;; programmatically reconfigure the bundling if you know which stream names should
;; belong together
(bind-type MIDIDevice <List{Pair{i32,i8*}*}*,List{Pair{i32,i8*}*}*> (constructor? . #f) (printer? . #f))



(bind-func MIDIDevice:[MIDIDevice*,List{Pair{i32,i8*}*}*,List{Pair{i32,i8*}*}*]*
  (lambda (input_ports output_ports)
    (let ((md:MIDIDevice* (alloc)))
      (tfill! md input_ports output_ports)
      md)))


(bind-func input_ports:[List{Pair{i32,i8*}*}*,MIDIDevice*]*
  (lambda (device)
    (tref device 0)))


(bind-func output_ports:[List{Pair{i32,i8*}*}*,MIDIDevice*]*
  (lambda (device)
    (tref device 1)))


(bind-type MIDIDeviceManager <List{MIDIDevice*}*> (constructor? . #f) (printer? . #f))
(bind-func MIDIDeviceManager:[MIDIDeviceManager*,List{MIDIDevice*}*]*
  (lambda (devices)
    (let ((mdm:MIDIDeviceManager* (alloc)))
      (tset! mdm 0 devices)
      mdm)))

(bind-func devices:[List{MIDIDevice*}*,MIDIDeviceManager*]*
  (lambda (manager)
    (tref manager 0)))




;; MIDIDeviceManager data type. Fields are input_streams, output_streams
;; (bind-type MIDIDeviceManager <List{Pair{i8*,i1}*}*,List{Pair{i8*,i1}*}*> (constructor? . #f) (printer? . #f))
;; (bind-func MIDIDeviceManager:[MIDIDeviceManager*,List{Pair{i8*,i1}*}*,List{Pair{i8*,i1}*}*]*
;;   (lambda (input_devices output_devices)
;;     (let ((mdm:MIDIDeviceManager* (alloc)))
;;       (tset! mdm 0 input_devices)
;;       (tset! mdm 1 output_devices)
;;       mdm)))

;; (bind-func input_devices:[List{Pair{i8*,i1}*}*,MIDIDeviceManager*]*
;;   (lambda (mdm)
;;     (tref mdm 0)))

;; (bind-func input_devices:[List{Pair{i8*,i1}*}*,MIDIDeviceManager*,List{Pair{i8*,i1}*}*]*
;;   (lambda (mdm in_devices)
;;     (tset! mdm 0 in_devices)))

;; (bind-func output_devices:[List{Pair{i8*,i1}*}*,MIDIDeviceManager*]*
;;   (lambda (mdm)
;;     (tref mdm 1)))

;; (bind-func output_devices:[List{Pair{i8*,i1}*}*,MIDIDeviceManager*,List{Pair{i8*,i1}*}*]*
;;   (lambda (mdm in_devices)
;;     (tset! mdm 1 in_devices)))

;; (bind-func add_input_device:[void,MIDIDeviceManager*,PmStream*]*
;;   (lambda (mdm dev)
;;     (input_devices mdm (cons (Pair (cast dev i8*) #t) (input_devices mdm)))
;;     void))

;; (bind-func add_output_device:[void,MIDIDeviceManager*,PmStream*]*
;;   (lambda (mdm dev)
;;     (output_devices mdm (cons (Pair (cast dev i8*) #t) (output_devices mdm)))
;;     void))


;; (bind-func add_all_devices:[void,MIDIDeviceManager*]*
;;   (lambda (mdm)
;;     (let ((ndev (Pm_CountDevices)))
;;       (if (= ndev 0)
;;           (println "No MIDI devices found")
;;           (begin
;;             (println "\n-- Adding MIDI input devices --\n")
;;             (doloop (i ndev)
;;               (if (= (tref (Pm_GetDeviceInfo i) 3) 1)
;;                   (let ((stream (pm_create_input_stream i)))
;;                     (add_input_device mdm stream)
;;                     (println "  device id" i ":" (Pm_GetDeviceInfo i)))))
;;             (println "\n-- Adding MIDI output devices --\n")
;;             (doloop (i ndev)
;;               (if (= (tref (Pm_GetDeviceInfo i) 4) 1)
;;                   (let ((stream (pm_create_output_stream i)))
;;                     (add_output_device mdm stream)
;;                     (println "  device id" i ":" (Pm_GetDeviceInfo i))))))))))



(bind-func pm_print_devices
  (lambda ()
    (let ((ndev (Pm_CountDevices)))
      (if (= ndev 0)
          (println "No MIDI devices found")
          (begin
            (println "\n-- MIDI input devices --\n")
            (doloop (i ndev)
              (if (= (tref (Pm_GetDeviceInfo i) 3) 1)
                  (println "  device id" i ":" (Pm_GetDeviceInfo i))))
            (println "\n-- MIDI output devices --\n")
            (doloop (i ndev)
              (if (= (tref (Pm_GetDeviceInfo i) 4) 1)
                  (println "  device id" i ":" (Pm_GetDeviceInfo i)))))))))


(pm_initialize)
(pm_print_devices)


(bind-func note_on:[void,PmStream*,i64,i64,i64]*
  (lambda (dev pitch velocity channel)
    (Pm_WriteShort dev 0 (Pm_Message (i64toi32 (+ 144 channel)) (i64toi32 pitch) (i64toi32 velocity)))
    void))

(bind-func note_off:[void,PmStream*,i64,i64]*
  (lambda (dev pitch channel)
    (Pm_WriteShort dev 0 (Pm_Message (i64toi32 (+ 144 channel)) (i64toi32 pitch) (i64toi32 0)))
    void))
    
(bind-func play_note:[void,i64,PmStream*,i64,i64,i64,i64]*
  (lambda (time dev pitch velocity channel duration)
    (callback time note_on dev pitch velocity channel)
    (callback (+ time duration) note_off dev pitch channel)
    void))

;;(my_play_note (now) (output) 30 100 0 44100)

(bind-func msg_type:[i32,i32]*
  (lambda (s)
    (dtoi32 (round (* (floor (/ (i32tod s) 16.)) 16.)))))

(bind-func msg_chan:[i32,i32]*
  (lambda (s)
    (- s (msg_type s))))

;(msg_chan 145)

(bind-func midi_read_loop_go:[i64]* (lambda () 1))

(bind-func receive_note_on:[void,PmStream*,i32,i32,i32]*
  (lambda (dev pitch velocity channel)
    (println "Note On  pitch: " pitch "  vel: " velocity)))
    

(bind-func receive_note_off:[void,PmStream*,i32,i32,i32]*
  (lambda (dev pitch velocity channel)
    (println "Note Off  pitch: " pitch "  vel: " velocity)))


(bind-func receive_cc:[void,PmStream*,i32,i32,i32]*
  (lambda (dev controller value channel)
    (println "CC  controller: " controller "  value: " value)))

(bind-func receive_aftertouch:[void,PmStream*,i32,i32,i32]*
  (lambda (dev pitch value channel)
    (println "Aftertouch  pitch: " pitch "  value: " value)))


(bind-func midi_read_loop:[void,i64,double,MIDIDeviceManager]*
  (let ((input_buffer:PmEvent* (zalloc PM_MIDI_BUFFER_SIZE))
        (read_count 0)
        (i:i32 0))
    (lambda (time:i64 delta_t:double mdm:MIDIDeviceManager*)
      (let ((tmp
       (lambda (device:Pair{i8*,i1}*)
         (let ((dev:PmStream* (cast (first device) PmStream*))
               (enabled:i1 (second device)))
           (if enabled
               (begin
                 (set! read_count (Pm_Read dev input_buffer PM_MIDI_BUFFER_SIZE))
                 (println "read_count:" (convert read_count i32))
                 (if (> read_count 0)
                     (dotimes (i read_count)
                       (cond
                        ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_NOTE_ON)
                         (receive_note_on
                          dev
                          (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
                          ))
                        ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_NOTE_OFF)
                         (receive_note_off
                          dev
                          (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
                          ))
                        ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_CC)
                         (receive_cc
                          dev
                          (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
                          ))
                        ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_POLY_AFTERTOUCH)
                         (receive_aftertouch
                          dev
                          (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
                          (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
                          ))
                        (else
                         ;(printf "%d\n" (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
                         ;;(println "midi recv:" i (pref-ptr input_buffer i))
                         void)))
                     (else void)))
               (else void))))))
        (for-each tmp (input_devices mdm)))
      (let ((next_time (+ time (convert (* SRd delta_t)))))
        (cond
         ((= (midi_read_loop_go) 1)
          (callback next_time midi_read_loop next_time delta_t mdm)
          void)
         (else void))))))



(bind-func midi_read_loop:[void,i64,double,PmStream*]*
  (let ((input_buffer:PmEvent* (zalloc PM_MIDI_BUFFER_SIZE))
        (read_count 0)
        (i:i32 0))
    (lambda (time:i64 delta_t:double dev:PmStream*)
      (set! read_count (Pm_Read dev input_buffer PM_MIDI_BUFFER_SIZE))
      ;(println "read_count:" (convert read_count i32))
      (if (> read_count 0)
          (dotimes (i read_count)
            (cond
             ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_NOTE_ON)
              (receive_note_on
               dev
               (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
               (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
               (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
               ))
             ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_NOTE_OFF)
              (receive_note_off
               dev
               (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
               (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
               (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
               ))
             ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_CC)
              (receive_cc
               dev
               (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
               (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
               (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
               ))
             ((= (msg_type (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i)))) MIDI_POLY_AFTERTOUCH)
              (receive_aftertouch
               dev
               (Pm_Message_Data1 (Pm_Event_Message (pref-ptr input_buffer i)))
               (Pm_Message_Data2 (Pm_Event_Message (pref-ptr input_buffer i)))
               (msg_chan (Pm_Message_Status (Pm_Event_Message (pref-ptr input_buffer i))))
               ))
             (else void)))
          (else void))
      (let ((next_time (+ time (convert (* SRd delta_t)))))
        (cond
         ((= (midi_read_loop_go) 1)
          (callback next_time midi_read_loop next_time delta_t dev)
          void)
         (else void))))))




(bind-func midi_input_shazam:[PmStream*,i8*]*
  (lambda (portname:i8*)
    (let ((ndev (Pm_CountDevices))
          (n:i32 (- ndev 1))
          (loop:[i32,i32]*
           (lambda (i)
             (cond
              ((>= i 0)
               (if (and
                    (= (strcmp portname (tref (Pm_GetDeviceInfo i) 2)) (i64toi32 0))
                    (= (tref (Pm_GetDeviceInfo i) 3) 1))
                   i
                   (loop (- i 1))))
              (else -1)))))
      (let ((m (loop n)))
        (if (>= m 0)
            (let ((stream (pm_create_input_stream m)))
              (midi_read_loop (now) 0.01))
            null)))))
                   

(bind-func midi_output_shazam:[PmStream*,i8*]*
  (lambda (portname:i8*)
    (let ((ndev (Pm_CountDevices))
          (n:i32 (- ndev 1))
          (loop:[i32,i32]*
           (lambda (i)
             (cond
              ((>= i 0)
               (if (and
                    (= (strcmp portname (tref (Pm_GetDeviceInfo i) 2)) (i64toi32 0))
                    (= (tref (Pm_GetDeviceInfo i) 4) 1))
                   i
                   (loop (- i 1))))
              (else -1)))))
      (let ((m (loop n)))
        (if (>= m 0)
            (pm_create_output_stream m)
            null)))))






















;; Scheme MIDI I/O

;; let's grab a handle for our midi out device in scheme
;;(bind-func get_midi_out
 ;; (lambda ()
  ;;  midi_out))
;;(define *midi-out* (get_midi_out))

;;(play-midi-note (now) *midi-out* (random 60 72) (random 60 90) 44100)




;;;;;;;;;; OLD RTMIDI Stuff ;;;;;;;;;;


;; ;; Dependencies
;; (sys:load "libs/external/rtmidi.xtm")
;; ;(sys:load "libs/external/rtmidi-scm.xtm")

;; ;(bind-alias midi_callback [i8*,double,i64,i8*]*)
;; (bind-func midi_handler:[void,i8,i8,i8,i8]*
;;   (lambda (type chan a b)
;;     (println type chan a b)
;;     void))

;; (bind-func midi_receive
;;   (let ((type:i8 0) (chan:i8 0) (a:i8 0) (b:i8 0))
;;     (lambda (time:double len:i64 msg:i8*)
;;       (set! type (>> (pref msg 0) 4))
;;       (set! chan (& (pref msg 0) 15))
;;       (set! a (pref msg 1))
;;       (set! b (pref msg 2))
;;       (midi_handler type chan a b)
;;       void)))

;; (bind-func midi_available_inputs:[i8*]*
;;   (lambda ()
;;     (let* ((dev (midi_new_indevice))
;;            (num_ports (getInPortCount dev))
;;            (output:i8* (zalloc 4096))
;;            (tmp:i8* output)
;;            (i:i64 0))
;;       (dotimes (i num_ports)
;;         (set! tmp (pref-ptr tmp (sprintf tmp "Port %lld: %s\n" i (getInPortName dev i)))))
;;       (midi_delete_indevice dev)
;;       (free dev)
;;       (printf "%s" output)
;;       output)))

;; (bind-func midi_available_outputs:[i8*]*
;;   (lambda ()
;;     (let* ((dev (midi_new_outdevice))
;;            (num_ports (getOutPortCount dev))
;;            (output:i8* (zalloc 4096))
;;            (tmp:i8* output)
;;            (i:i64 0))
;;       (dotimes (i num_ports)
;;         (set! tmp (pref-ptr tmp (sprintf tmp "Port %lld: %s\n" i (getOutPortName dev i)))))
;;       (midi_delete_outdevice dev)
;;       (free dev)
;;       (printf "%s" output)
;;       output)))


;; (bind-func midi_input_shazam:[midi_in_device*,i8*]*
;;   (lambda (portname:i8*)
;;     (let ((dev:midi_in_device* (zalloc)))
;;       (newMidiInDevice dev UNSPECIFIED "Extempore Midi Input Device")
;;       (let ((num_ports (getInPortCount dev))
;;             (i:i64 0))
;;         (dotimes (i num_ports)
;;           (if (= (strcmp portname (getInPortName dev i)) (i64toi32 0))
;;               (let ((success (openInPort dev i portname)))
;;                 (if (= (i64toi32 0) success)
;;                     (begin
;;                       (midi_register_device dev "midi_receive")
;;                       (printf "Successfully opened input port: %s\n" portname))
;;                     (printf "Failed to open input port: %s\n" portname))))))
;;       dev)))



;; (bind-func midi_output_shazam:[midi_out_device*,i8*]*
;;   (lambda (portname:i8*)
;;     (let ((dev:midi_out_device* (zalloc)))
;;       (newMidiOutDevice dev UNSPECIFIED "Extempore Midi Output Device")
;;       (let ((num_ports (getOutPortCount dev))
;;             (i:i64 0))
;;         (dotimes (i num_ports)
;;           (if (= (strcmp portname (getOutPortName dev i)) (i64toi32 0))
;;               (let ((success (openOutPort dev i portname)))
;;                 (if (= (i64toi32 0) success)
;;                     (printf "Successfully opened output port: %s\n" portname)
;;                     (printf "Failed to open output port: %s\n" portname))))))
;;       dev)))


;;;;;;;;;;;;;;;;;
;; Example Usage
;;
;; ;; Sending MIDI ;;
;; (define to_iac (midi_output_shazam "IAC Driver Bus 1"))
;; (midi_send to_iac MIDI_NOTE_ON (i64toi8 0) pitch velocity)
;;
;; ;; Receiving MIDI ;;
;; (define from_iac (midi_input_shazam "IAC Driver Bus 1"))
;; (bind-func midi_handler:[void,i8,i8,i8,i8]*
;;  (lambda (type chan a b)
;;    (println "MIDI Received")  
;;    (println type chan a b)
;;    void))
;;
;; ;; NOTE - by default this merges all MIDI from all devices and ports
;; ;; if you want to have a particular distinct MIDI handler for a given device/port
;; ;; you need to do this for example

;; (bind-func iac_midi_handler:[void,i8,i8,i8,i8]*
;;  (lambda (type chan a b)
;;    (println "MIDI Received from IAC port 1")  
;;    (println type chan a b)
;;    void))
;;
;; (bind-func midi_receive
;;  (let ((type:i8 0) (chan:i8 0) (a:i8 0) (b:i8 0))
;;    (lambda (time:double len:i64 msg:i8*)
;;      (set! type (>> (pref msg 0) 4))
;;      (set! chan (& (pref msg 0) 15))
;;      (set! a (pref msg 1))
;;      (set! b (pref msg 2))
;;      (iac_midi_handler type chan a b)
;;      void)))
;;
;; (midi_register_device from_iac "iac_midi_handler")
;;
;;
;;;;;;;;;;;;;;;;
						
			
(define *xtmlib-ybot_midi-loaded* #t)
