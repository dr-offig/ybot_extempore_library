(if (and (defined? '*xtmlib-ybot-parser-loaded*) *xtmlib-ybot-parser-loaded*)
    (sys:load-escape "ybot_parser library already loaded"))
(define *xtmlib-ybot-parser-loaded* #f)

(define *ybot-lib-dir* "/Users/s2805534/Dropbox/ybot/src/extempore_libs")
(if (not (defined? '*ybot-lib-dir*))
    (sys:load-escape "Set the *ybot-lib-dir* variable before loading this library"))
(sys:load (string-append *ybot-lib-dir* "/ybot_filesystem.xtm"))         
(sys:load (string-append *ybot-lib-dir* "/ybot_dynamic_buffer.xtm"))         


;; (bind-func test_nest:[bool,String*]*
;;   (lambda (a:String*)
;;     (let* ((q:String* (Str "Toby"))
;;            (lazy_function:[bool,String*]*
;;             (lambda (b:String*)
;;               (let ((diligent_function:[bool,String*]*
;;                      (lambda (c:String*)
;;                        (equal c q))))
;;                 (diligent_function b)))))
;;       (lazy_function a))))

;; ($ (test_nest null))
                     

(bind-type CharStream <apr_file_t*,bool*>)

(bind-func end_of_stream:[bool,CharStream*]*
  (lambda (stream)
    (@ (tref stream 1))))

(bind-func next:[i8,CharStream*]*
  (lambda (stream)
    (yfs_read_byte (tref stream 0) (tref stream 1))))

(bind-func peek:[i8,CharStream*]*
  (lambda (stream)
    (yfs_peek_byte (tref stream 0))))

(bind-func goto:[bool,CharStream*,i64]*
  (lambda (stream index)
    (let ((new_index:i64 (yfs_file_seek (tref stream 0) index)))
      (= new_index index))))

(bind-func goto_start:[bool,CharStream*]*
  (lambda (stream)
    (goto stream 0)))
    
(bind-func playhead:[i64,CharStream*]*
  (lambda (stream)
    (yfs_current_playhead (tref stream 0))))

(bind-func step_back:[bool,CharStream*]*
  (lambda (stream)
    (goto stream (- (playhead stream) 1))))

(bind-func skip_whitespace:[bool,CharStream*]*
  (lambda (stream)
    (cond
     ((not (end_of_stream stream))
      (let ((c:i8 (next stream)))
        (cond ;;   space        tab          CR             LF
         ((or (= c 32:i8) (= c 9:i8) (= c 13:i8) (= c 10:i8))
          (skip_whitespace stream))
         (else
          (step_back stream)
          #t))))
     (else #f))))


(bind-func look_ahead:[String*,CharStream*,i64]*
  (lambda (stream:CharStream* n:i64)
    (let* ((i:i64 0)
           (ahead:i8* (salloc (+ n 1)))
           (look_loop:[bool,i64]*
              (lambda (cc)
                (cond
                 ((end_of_stream stream) #f)
                 ((<= n cc) #t)
                 (else
                  (pset! ahead cc (next stream))
                  (look_loop (+ cc 1)))))))
        (cond
         ((look_loop 0)
          (pset! ahead n 0:i8)
          (goto stream (- (playhead stream) n))
          (String ahead))
         (else
          (goto stream (- (playhead stream) n))
          null)))))
  
  

(bind-func look_ahead_match:[bool,CharStream*,String*]*
  (lambda (stream:CharStream* str:String*)
    (cond
     ((or (null? str) (null? stream)) #f)
     (else
      (let* ((i:i64 0) (n:i64 (length str))
             (ahead:i8* (salloc (+ n 1)))
             (look_loop:[bool,i64]*
              (lambda (cc)
                (cond
                 ((end_of_stream stream) #f)
                 ((<= n cc) #t)
                 (else
                  (pset! ahead cc (next stream))
                  (look_loop (+ cc 1)))))))
        (cond
         ((look_loop 0)
          (pset! ahead n 0:i8)
          (goto stream (- (playhead stream) n))
          (= 0:i32 (strcmp ahead (cstring str))))
         (else
          (goto stream (- (playhead stream) n))
          #f)))))))
                 

    


;;;;;;;;;;;;;;; HTML Stuff ;;;;;;;;;;;;;;;;;

;; HTML Tag: label, parent, children, attributes, contents, _properties
;; use 'opaque' i8* for List{HTMLTag*}*
(bind-type HTMLTag <String*,HTMLTag*,i8*,List{Pair{String*,String*}*}*,String*,i8> (constructor? . #f) (printer? . #f))

;; provide our own constructor - hide i8* with 'hidden' cast from List{HTMLTag*}* 
(bind-func HTMLTag:[HTMLTag*,String*,HTMLTag*,List{HTMLTag*}*,List{Pair{String*,String*}*}*,String*,i8]*
  (lambda (label parent children attributes contents properties)
    (let ((tag:HTMLTag* (alloc)))
      (tfill! tag label parent (cast children i8*) attributes contents properties)
      tag)))

;; getters and setters 
(bind-func label (lambda (tag:HTMLTag*) (tref tag 0)))
(bind-func label (lambda (tag:HTMLTag* label_in:String*) (tset! tag 0 label_in)))
(bind-func parent (lambda (tag:HTMLTag*) (tref tag 1)))
(bind-func parent (lambda (tag:HTMLTag* parent_in:HTMLTag*) (tset! tag 1 parent_in)))
(bind-func children (lambda (tag:HTMLTag*) (cast (tref tag 2) List{HTMLTag*}*)))
(bind-func children (lambda (tag:HTMLTag* children_in:List{HTMLTag*}*) (cast (tset! tag 2 (cast children_in i8*)) List{HTMLTag*}*)))
(bind-func attributes (lambda (tag:HTMLTag*) (tref tag 3)))
(bind-func attributes (lambda (tag:HTMLTag* attrs_in:List{Pair{String*,String*}*}*) (tset! tag 3 attrs_in)))
(bind-func contents (lambda (tag:HTMLTag*) (tref tag 4)))
(bind-func contents (lambda (tag:HTMLTag* contents_in:String*) (tset! tag 4 contents_in)))
(bind-func properties (lambda (tag:HTMLTag*) (tref tag 5)))
(bind-func properties (lambda (tag:HTMLTag* properties_in:i8) (tset! tag 5 properties_in)))

;; helpers
(bind-func void_element (lambda (tag:HTMLTag*) (= (& (properties tag) #x1) #x1)))
(bind-func set_void_element (lambda (tag:HTMLTag*) (properties tag (bor (properties tag) #x1))))
(bind-func no_self_nesting_element (lambda (tag:HTMLTag*) (= (& (properties tag) #x2) #x2)))
(bind-func set_no_self_nesting_element (lambda (tag:HTMLTag*) (properties tag (bor (properties tag) #x2))))
(bind-func push_attribute (lambda (tag:HTMLTag* attr:Pair{String*,String*}*) (attributes tag (cons attr (attributes tag)))))
(bind-func pop_attribute (lambda (tag:HTMLTag*) (let ((attr (car (attributes tag)))) (attributes tag (cdr (attributes tag))) attr)))
(bind-func add_child (lambda (tag:HTMLTag* child:HTMLTag*) (children tag (cons child (children tag)))))

(bind-val htmlOpenAngleBracket i8 (i64toi8 60))
(bind-val htmlCloseAngleBracket i8 (i64toi8 62))
(bind-val htmlBackSlash i8 (i64toi8 92))
(bind-val htmlForwardSlash i8 (i64toi8 47))
(bind-val htmlSpace i8 (i64toi8 32))
(bind-val htmlEquals i8 (i64toi8 61))
(bind-val htmlDoubleQuote i8 (i64toi8 34))
(bind-val htmlTab i8 (i64toi8 9))
(bind-val htmlCarriageReturn i8 (i64toi8 13))
(bind-val htmlLineFeed i8 (i64toi8 10))
(bind-val ybotHtmlPlaceHolder i8 (i64toi8 26))


(bind-func print_shallow:[void,HTMLTag*,i64]*
  (lambda (tag depth)
    (if (non-null tag)
        (let* ((name:String* (label tag))
               (attr:List{Pair{String*,String*}*}*  (attributes tag))
               (cntnts:String* (contents tag)))
          (doloop (i depth)
            (printf "\t"))
          (if (non-null name) (printf "<%s" (cstring name)) (printf "<%s" "unknown"))
          (let ((attr_printer:[void,Pair{String*,String*}*]*
                 (lambda (a:Pair{String*,String*}*)
                   (cond
                    ((non-null a)
                     (if (non-null (first a)) (begin (printf " %s" (cstring (first a))) void) void)
                     (if (non-null (second a)) (begin (printf "=%c%s%c" htmlDoubleQuote (cstring (second a)) htmlDoubleQuote) void) void))
                    (else void)))))
            (for-each attr_printer (reverse attr)))
          (printf ">")
          (if (not (void_element tag))
              (begin
                (highlighter "black")
                (print_sanitised cntnts)
                (highlighter "normal")
                void)
              void))
        (begin
          (printf "<NULL TAG>")
          void))
      void))
      
(bind-func print_deep:[void,HTMLTag*,i64]*
  (lambda (tag depth)
    (cond
     ((non-null tag)
      (print_shallow tag depth)
      (printf "\n")
      (for-each (lambda (child) (print_deep child (+ depth 1))) (reverse (children tag)))
      (if (not (void_element tag))
          (let ((i:i64 0))
            (dotimes (i depth)
              (printf "\t"))))
      (if (and (non-null (label tag)) (not (void_element tag)))
          (printf "</%s>\n" (cstring (label tag))))
      void)
     (else void))))


(bind-func print:[void,HTMLTag*]*
  (lambda (tag) (cond ((non-null tag) (print_deep tag 0)) (else void))))
      


;; Contexts - We are always inside some element
;; Inside tag 
;; -- in label
;;    -- in literal
;;    -- else
;; -- in attributes
;;    -- in literal
;;    -- else
;; -- else

;; Context encoding
(bind-val HTML_TAG_CONTENT i8                       (binary "00000000"))
(bind-val HTML_TAG_LABEL i8                             (binary "00000001"))
(bind-val HTML_TAG_ATTRIBUTE_NAME i8        (binary "00000010"))
(bind-val HTML_TAG_ATTRIBUTE_VALUE i8       (binary "00000100"))
(bind-val HTML_TAG_LITERAL i8                          (binary "00001000"))
(bind-val HTML_TAG_ESCAPE i8                          (binary "00010000"))
(bind-val HTML_TAG_END_LABEL i8                    (binary "00100000"))
(bind-val HTML_TAG_FRESH i8                             (binary "01000000"))
(bind-val HTML_DEFAULT i8                                  (binary "10000000"))

(bind-func name_of_state:[String*,i8]*
  (lambda (state:i8)
    (cond
     ((= state (binary "00000000")) (String "CONTENT"))
     ((= state (binary "00000001")) (String "LABEL"))
     ((= state (binary "00000010")) (String "ATTRIBUTE_NAME"))
     ((= state (binary "00000100")) (String "ATTRIBUTE_VALUE"))
     ((= state (binary "00001000")) (String "LITERAL"))
     ((= state (binary "00010000")) (String "ESCAPE"))
     ((= state (binary "00100000")) (String "END_LABEL"))
     ((= state (binary "01000000")) (String "FRESH"))
     ((= state (binary "10000000")) (String "DEFAULT"))
     (else (String "UNKNOWN")))))
     

;; Halting conditions for contextual parsers
(bind-alias halting_cond_t [bool,i8]*)

(bind-func html_default_cond:halting_cond_t
 (lambda (c)
   (contains c (list htmlCloseAngleBracket))))

(bind-func html_literal_cond:halting_cond_t
 (lambda (c)
   (contains c (list htmlDoubleQuote))))
           
(bind-func html_content_cond:[bool,i8]*
 (lambda (c)
   (contains c (list htmlOpenAngleBracket htmlDoubleQuote))))

(bind-func html_label_cond:[bool,i8]*
 (lambda (c)
   (contains c (list htmlCloseAngleBracket htmlForwardSlash htmlSpace htmlDoubleQuote))))

(bind-func html_end_label_cond:[bool,i8]*
 (lambda (c)
   (contains c (list htmlCloseAngleBracket))))

(bind-func html_attribute_value_cond:[bool,i8]*
 (lambda (c)
   (contains c (list htmlCloseAngleBracket htmlForwardSlash htmlDoubleQuote htmlSpace))))

(bind-func html_attribute_name_cond:[bool,i8]*
 (lambda (c)
   (contains c (list htmlCloseAngleBracket htmlForwardSlash htmlDoubleQuote htmlSpace htmlEquals))))

(bind-func html_contents_cond:[bool,i8]*
 (lambda (c)
   (contains c (list htmlOpenAngleBracket htmlForwardSlash))))


(bind-alias parser_t [bool,CharStream*]*)

(bind-type HTMLParseContext <HTMLTag*,StringStreamBuffer*,halting_cond_t,i8> (constructor? . #f) (printer? . #f))

;; provide our own constructor
(bind-func HTMLParseContext:[HTMLParseContext*,HTMLTag*,halting_cond_t,i8]*
  (lambda (tag condition state)
    (let ((context:HTMLParseContext* (alloc)))
      (tset! context 0 tag)
      (tset! context 1 (StringStreamBuffer_c 256))
      (tset! context 2 condition)
      (tset! context 3 state)
      context)))


;; getters and setters 
(bind-func tag (lambda (context:HTMLParseContext*) (tref context 0)))
(bind-func tag (lambda (context:HTMLParseContext* tag_in:HTMLTag*) (tset! context 0 tag_in)))
(bind-func buffer (lambda (context:HTMLParseContext*) (tref context 1)))
(bind-func buffer (lambda (context:HTMLParseContext* buffer_in:StringStreamBuffer*) (tset! context 1 buffer_in)))
(bind-func condition (lambda (context:HTMLParseContext*) (tref context 2)))
(bind-func condition (lambda (context:HTMLParseContext* condition_in:halting_cond_t) (tset! context 2 condition_in)))
(bind-func state (lambda (context:HTMLParseContext*) (tref context 3)))
(bind-func state (lambda (context:HTMLParseContext* state_in:i8) (tset! context 3 state_in)))

(bind-func replicate:[HTMLParseContext*,HTMLParseContext*]*
  (lambda (context)
    (let ((new_context:HTMLParseContext* (alloc)))
      (tset! new_context 0 (tag context))
      (tset! new_context 1 (buffer context))
      (tset! new_context 2 (condition context))
      (tset! new_context 3 (state context))
      new_context)))


(bind-func replicate_into_literal:[HTMLParseContext*,HTMLParseContext*]*
  (lambda (context)
    (let ((new_context:HTMLParseContext* (alloc)))
      (tset! new_context 0 (tag context))
      (tset! new_context 1 (buffer context))
      (tset! new_context 2 html_literal_cond)
      (tset! new_context 3 HTML_TAG_LITERAL)
      new_context)))



(bind-func HTMLParseContext_default:[HTMLParseContext*]*
  (lambda ()
    (let* ((context:HTMLParseContext* (alloc))
           (tag:HTMLTag* (HTMLTag (String "Document") null null null (String "") (binary "00000000")))
           (buffer:StringStreamBuffer* (StringStreamBuffer_c 256))
           (state HTML_DEFAULT))
      (tfill! context tag buffer html_default_cond state)
      context)))
      

(bind-func print_context:[void,HTMLParseContext*]*
  (lambda (ctxt)
    (cond
     ((non-null ctxt)
      (printf "State: %s \tTag: " (cstring (name_of_state (state ctxt))))
      (print_shallow (tag ctxt) 0)
      (cond
       ((non-null (buffer ctxt))
        (print_sanitised (toString (buffer ctxt)))))
      (printf "\n")
      void)
    (else void))))

(bind-func print_context_brief:[void,HTMLParseContext*]*
  (lambda (ctxt)
    (cond
     ((non-null ctxt)
      (printf "State: %s \tTag: " (cstring (name_of_state (state ctxt))))
      (print_shallow (tag ctxt) 0)
      (printf "\n")
      void)
    (else void))))


(bind-type HTMLParseContextStack <List{HTMLParseContext*}*> (constructor? . #f) (printer? . #f))

(bind-func HTMLParseContextStack:[HTMLParseContextStack*]*
  (lambda ()
    (let* ((stack:HTMLParseContextStack* (alloc))
           (context_list:List{HTMLParseContext*}* (list (HTMLParseContext_default))))
      (tfill! stack context_list)
      stack)))

(bind-func head:[List{HTMLParseContext*}*,HTMLParseContextStack*]* (lambda (stack:HTMLParseContextStack*) (tref stack 0)))
(bind-func head (lambda (stack:HTMLParseContextStack* head_in:List{HTMLParseContext*}*) (tset! stack 0 head_in)))

(bind-func print_context_stack:[void,HTMLParseContextStack*]*
  (lambda (stack)
    (for-each print_context (head stack))))

(bind-func print_context_stack_brief:[void,HTMLParseContextStack*]*
  (lambda (stack)
    (for-each print_context_brief (head stack))))


(bind-func pop:[HTMLParseContext*,HTMLParseContextStack*]*
  (lambda (stack)
    (cond
     ((non-null stack)
      (printf "Popping stack\n")
      (print_context_stack_brief stack)
      (let ((lst (head stack)))
        (cond
         ((non-null lst)
          (cond
           ((< 0 (length lst))
            (cond
             ((< 1 (length lst))
              (let ((top_context:HTMLParseContext* (car lst)))
                (head stack (cdr lst))
                top_context))
             (else
              (car lst))))
            (else
             (printf "Stack has no elements!\n")
             (HTMLParseContext_default))))
          (else
           (printf "List of contexts is null!\n")
           (HTMLParseContext_default)))))
     (else
      (printf "Stack is null!\n")
      (HTMLParseContext_default)))))


(bind-func push:[HTMLParseContextStack*,HTMLParseContextStack*,HTMLParseContext*]*
  (lambda (stack context)
    (printf "Pushing context:\n")
    (print_context_brief context)
    (cond
     ((non-null stack)
      (printf "onto stack:\n")
      (print_context_stack_brief stack)
      (head stack (cons context (head stack)))
      stack)
     (else
      (let ((output:HTMLParseContextStack* (HTMLParseContextStack)))
        (head output (cons context (head output)))
        (set! stack output)
        stack)))))


(bind-func bottom:[HTMLParseContext*,HTMLParseContextStack*]*
  (lambda (stack:HTMLParseContextStack*)
    (cond
     ((non-null stack)
      (car (last (head stack))))
     (else null))))


(bind-func top:[HTMLParseContext*,HTMLParseContextStack*]*
  (lambda (stack)
    (car (head stack))))


(bind-func tag:[HTMLTag*,HTMLParseContextStack*]*
  (lambda (stack)
    (tag:[HTMLTag*,HTMLParseContext*]* (top stack))))

(bind-func buffer:[StringStreamBuffer*,HTMLParseContextStack*]*
  (lambda (stack)
    (buffer:[StringStreamBuffer*,HTMLParseContext*]* (top stack))))

(bind-func condition:[halting_cond_t,HTMLParseContextStack*]*
  (lambda (stack)
    (condition:[halting_cond_t,HTMLParseContext*]* (top stack))))

(bind-func state:[i8,HTMLParseContextStack*]*
  (lambda (stack)
    (state:[i8,HTMLParseContext*]* (top stack))))



(bind-func parser_c:[parser_t,HTMLParseContext*]*
  (lambda (context)
    (letrec
        ((parser:parser_t
          (lambda (stream)
            (cond
             ((not (end_of_stream stream))
              (let* ((c:i8 (next stream)))
                (highlighter "red") (printf "%c" c) (highlighter "normal")
                (cond
                 (((condition context) c)
                  (printf "\n --- Encountered %c --- stopped parsing in context " c)
                  (print_context_brief context)
                  (step_back stream)
                  #t)
                 (else
                  (buffer context (write (buffer context) c))
                  (parser stream)))))
             (else #f)))))
      parser)))


;; (keep_parsing:[bool]*
;;  (lambda ()
;;    (printf "... resuming parsing of tag %s in state %s ... \n" (cstring (label (current_tag))) (cstring (name_of_state (current_state))))
;;    (char_reader stream (current_tag) (current_buffer) (current_condition))))

(bind-func collapse:[HTMLTag*,HTMLParseContextStack*]*
  (lambda (stack)
    (tag (bottom stack))))


(bind-func tail_matching_label:[List{HTMLParseContext*}*,HTMLParseContextStack*,String*]*
  (lambda (stack name)
    (let ((loop:[List{HTMLParseContext*}*,List{HTMLParseContext*}*]*
           (lambda (lst)
             (cond
              ((null? lst) null)
              ((equal (label (tag (car lst))) name) lst)
              (else (loop (cdr lst)))))))
      (loop (head stack)))))
     

(bind-func tail_not_matching_label:[List{HTMLParseContext*}*,HTMLParseContextStack*,String*]*
  (lambda (stack name)
    (let ((loop:[List{HTMLParseContext*}*,List{HTMLParseContext*}*]*
           (lambda (lst)
             (cond
              ((null? lst) null)
              ((not (equal (label (tag (car lst))) name)) lst)
              (else (loop (cdr lst)))))))
      (loop (head stack)))))


(bind-func tail_matching_tag:[List{HTMLParseContext*}*,HTMLParseContextStack*,HTMLTag*]*
  (lambda (stack:HTMLParseContextStack* aTag:HTMLTag*)
    (let ((loop:[List{HTMLParseContext*}*,List{HTMLParseContext*}*]*
           (lambda (lst)
             (cond
              ((null? lst) null)
              (else
               (let* ((ctxt:HTMLParseContext* (car lst))
                      (tg:HTMLTag* (tag ctxt)))
                 (cond 
                  ((= (cast tg i8*) (cast aTag i8*)) lst)
                  (else (loop (cdr lst))))))))))
      (loop (head stack)))))


(bind-func tail_not_matching_tag:[List{HTMLParseContext*}*,HTMLParseContextStack*,HTMLTag*]*
  (lambda (stack:HTMLParseContextStack* aTag:HTMLTag*)
    (let ((loop:[List{HTMLParseContext*}*,List{HTMLParseContext*}*]*
           (lambda (lst)
             (cond
              ((null? lst) null)
              (else
               (let* ((ctxt:HTMLParseContext* (car lst))
                      (tg:HTMLTag* (tag ctxt)))
                 (cond 
                  ((not (= (cast tg i8*) (cast aTag i8*))) lst)
                  (else (loop (cdr lst))))))))))
      (loop (head stack)))))



(bind-func pop_before_tail:[HTMLParseContextStack*,HTMLParseContextStack*,List{HTMLParseContext*}*]*
  (lambda (stack tail)
    (head stack tail)
    stack))
  

(bind-func pop_before_matching_label:[HTMLParseContextStack*,HTMLParseContextStack*,String*]*
  (lambda (stack name)
    (printf "Popping all tags until first tag labelled %s\n" (cstring name))
    (pop_before_tail stack (tail_matching_label stack name))))


(bind-func pop_while_matching_label:[HTMLParseContextStack*,HTMLParseContextStack*,String*]*
  (lambda (stack name)
    (printf "Popping all tags until first not labelled %s\n" (cstring name))
    (pop_before_tail stack (tail_not_matching_label stack name))))


(bind-func pop_before_matching_tag:[HTMLParseContextStack*,HTMLParseContextStack*,HTMLTag*]*
  (lambda (stack tag)
    (printf "Popping all tags until %p: " (cast tag i8*)) (print_shallow tag 0) (printf "\n")
    (pop_before_tail stack (tail_matching_tag stack tag))))


(bind-func pop_while_matching_tag:[HTMLParseContextStack*,HTMLParseContextStack*,HTMLTag*]*
  (lambda (stack tag)
    (printf "Popping all tags matching %p: " (cast tag i8*)) (print_shallow tag 0) (printf "\n")
    (pop_before_tail stack (tail_not_matching_tag stack tag))))


(bind-func pop_before_match:[HTMLParseContextStack*,HTMLParseContextStack*,[bool,HTMLParseContext*]*]*
  (lambda (stack predicate)
    (let ((loop:[List{HTMLParseContext*}*,List{HTMLParseContext*}*]*
           (lambda (lst)
             (cond
              ((null? lst) null)
              ((predicate (car lst)) lst)
              (else (loop (cdr lst)))))))
      (loop (head stack)))))
    

(bind-func pop_while_matching:[HTMLParseContextStack*,HTMLParseContextStack*,[bool,HTMLParseContext*]*]*
  (lambda (stack predicate)
    (let ((loop:[List{HTMLParseContext*}*,List{HTMLParseContext*}*]*
           (lambda (lst)
             (cond
              ((null? lst) null)
              ((not (predicate (car lst))) lst)
              (else (loop (cdr lst)))))))
      (loop (head stack)))))



(bind-func parse_html_stream:[HTMLTag*,CharStream*,HTMLParseContextStack*]*
  (lambda (stream:CharStream* stack:HTMLParseContextStack*)
    (cond
     ((end_of_stream stream)
      (collapse stack))
     (else
      (let ((parse:parser_t (parser_c (top stack))))
        (cond ;; 1a

         ((= (state stack) HTML_TAG_LITERAL)
          (cond
           ((parse stream)
            (pop stack)
            (next stream)
            (parse_html_stream stream stack))
           (else (collapse stack))))

         ((= (state stack) HTML_DEFAULT)
          (cond
           ((parse stream)
            (cond
             ((tail_match (buffer stack) (String "<HTML") #t)
              (printf "Found HTML start tag at index %lld\n" (playhead stream))
              (goto stream (- (playhead stream) 4))
              (let* ((child:HTMLTag* (HTMLTag (String "TBC") null null null (String "") (binary "00000000")))
                     (new_context:HTMLParseContext*  (HTMLParseContext child html_label_cond HTML_TAG_LABEL)))
                (add_child (tag stack) child)
                (printf "Added child tag %s to parent tag %s.\n" (cstring (label child)) (cstring (label (tag stack))))
                (push stack new_context))
              (parse_html_stream stream stack))
             (else
              (next stream)
              (parse_html_stream stream stack))))
           (else (collapse stack))))

         ((= (state stack) HTML_TAG_LABEL)
          (cond
           ((parse stream)
            (cond
             ((= (peek stream) htmlDoubleQuote)
              (push stack (replicate_into_literal (top stack)))
              (next stream)
              (parse_html_stream stream stack))
             ((= (peek stream) htmlSpace)
              (label (tag stack) (toString (buffer stack)))
              (printf "Tag label identified as %s\n" (cstring (label (tag stack))))
              (cond
               ((contains (lower (label (tag stack))) (list (Str "link") (Str "br") (Str "img") (Str "image")))
                (printf "Marking tag %s as void\n" (cstring (label (tag stack))))
                (set_void_element (tag stack))))
              (cond
               ((contains (lower (label (tag stack))) (list (String "li")))
                (printf "Marking tag %s as not allowing self-nesting\n" (cstring (label (tag stack))))
                (set_no_self_nesting_element (tag stack))))
              (let ((new_context:HTMLParseContext* (HTMLParseContext (tag stack) html_attribute_name_cond HTML_TAG_ATTRIBUTE_NAME)))
                (pop stack)
                (push stack new_context))
              (next stream)
              (parse_html_stream stream stack))
             ((= (peek stream) htmlCloseAngleBracket)
              (label (tag stack) (toString (buffer stack)))
              (printf "Tag label identified as %s\n" (cstring (label (tag stack))))
              (cond
               ((contains (lower (label (tag stack))) (list (String "li")))
                (printf "Marking tag %s as not allowing self-nesting\n" (cstring (label (tag stack))))
                (set_no_self_nesting_element (tag stack))))
              (cond
               ((contains (lower (label (tag stack))) (list (Str "link") (Str "br") (Str "img") (Str "image")))
                (printf "Marking tag %s as void\n" (cstring (label (tag stack))))
                (set_void_element (tag stack))
                (pop_while_matching_tag stack (tag stack))
                (next stream)
                (parse_html_stream stream stack))
               (else
                (let ((new_context:HTMLParseContext* (HTMLParseContext (tag stack) html_content_cond HTML_TAG_CONTENT)))
                  (pop stack)
                  (push stack new_context))
                (next stream)
                (parse_html_stream stream stack))))
             (else
              (next stream)
              (parse_html_stream stream stack))))
           (else (collapse stack))))

         
         ((= (state stack) HTML_TAG_ATTRIBUTE_NAME)
          (cond
           ((parse stream)
            (cond
             ((= (peek stream) htmlDoubleQuote)
              (push stack (replicate_into_literal (top stack)))
              (next stream)
              (parse_html_stream stream stack))
             ((= (peek stream) htmlCloseAngleBracket)
              (if (void_element (tag stack)) (pop_while_matching_tag stack (tag stack)))
              (let ((new_context:HTMLParseContext* (HTMLParseContext (tag stack) html_content_cond HTML_TAG_CONTENT)))
                (pop stack)
                (push stack new_context))
              (next stream)
              (parse_html_stream stream stack))
              (else
               (next stream)
               (parse_html_stream stream stack))))
           (else (collapse stack))))

         
         ((= (state stack) HTML_TAG_CONTENT)
          (cond
           ((parse stream)
            (cond
             ((= (peek stream) htmlDoubleQuote)
              (push stack (replicate_into_literal (top stack)))
              (next stream)
              (parse_html_stream stream stack))
             ((= (peek stream) htmlOpenAngleBracket)
              (next stream)
              (cond
               ((= (peek stream) htmlForwardSlash)
                (let ((new_context:HTMLParseContext* (HTMLParseContext (tag stack) html_end_label_cond HTML_TAG_END_LABEL)))
                  (state new_context HTML_TAG_END_LABEL)
                  (pop stack)
                  (push stack new_context))
                (next stream)
                (parse_html_stream stream stack))
               (else 
                (cond
                 ((no_self_nesting_element (tag stack))
                  (printf "Element %s does not allow self-nesting ... " (cstring (label (tag stack))))
                  (let ((str:String* (look_ahead stream 2)))
                    (printf "next two characters are %s\n" (cstring str))
                    (cond
                     ((equal str (label (tag stack)))
                      (printf "found %s attempting to self-nest. Popping back up to parent\n" (cstring (label (tag stack))))
                      (pop stack) void)
                     (else (printf "luckily the next tag is %s\n" (cstring str)) void))))
                 (else void))
                (printf "A child is born!\n")
                (let* ((child:HTMLTag* (HTMLTag (String "TBC") null null null (String "") (binary "00000000")))
                       (new_context:HTMLParseContext*  (HTMLParseContext child html_label_cond HTML_TAG_LABEL)))
                    (add_child (tag stack) child)
                    (printf "Added child tag %s to parent tag %s.\n" (cstring (label child)) (cstring (label (tag stack))))
                    ;;(printf "Added child tag %s to parent tag %s. Parent now:\n" (cstring (label child)) (cstring (label (tag stack))))
                    ;;(print (tag stack))
                    (push stack new_context))
                  (parse_html_stream stream stack))))
             (else
              (next stream)
              (parse_html_stream stream stack))))
           (else (collapse stack))))

         ((= (state stack) HTML_TAG_END_LABEL)
          (cond
           ((parse stream)
            (cond
             ((= (peek stream) htmlDoubleQuote)
              (push stack (replicate_into_literal (top stack)))
              (next stream)
              (parse_html_stream stream stack))
             ((= (peek stream) htmlCloseAngleBracket)
              (let ((closing_label:String* (toString (buffer stack))))
                (printf "Found closing label %s\n" (cstring closing_label))
                (pop_before_matching_label stack closing_label)
                (pop_while_matching_tag stack (tag stack)))
              (next stream)
              (parse_html_stream stream stack))
             (else
              (next stream)
              (parse_html_stream stream stack))))
           (else (collapse stack))))

         (else
          (printf "Shouldn't have gotten into this state %s\n" (name_of_state (state stack)))
          (collapse stack))))))))


(bind-func parse_html_file:[HTMLTag*,i8*]*
  (lambda (path)
    (let ((file (yfs_open path)))
      (if (non-null file)
          (let* ((eof:bool* (zalloc))
                 (stream:CharStream* (CharStream file eof))
                 (stack:HTMLParseContextStack* (HTMLParseContextStack)))
            (let ((output:HTMLTag* (parse_html_stream stream stack)))
              ;;(highlighter "white") (colour_pencil "black")
              (printf "\n")
              (highlighter "normal")
              (colour_pencil "normal")
              (if (non-null output) (print output))
              (yfs_close file)
              output))
          null))))


(parse_html_file "papers/0086/index.html")
                            


         

      ;;  ((= (state stack) HTML_TAG_LITERAL)
      ;;   (printf "Stopped in state HTML_TAG_LITERAL\n")
      ;;              (pop) ;; return to previous state (before literal was entered)
      ;;              (highlighter "red") (printf "%c" htmlDoubleQuote) (highlighter "normal")
      ;;              (next stream) ;; discard the double quote character
      ;;              ;; (printf "Popping out of literal state back to state %lld\n" (i8toi64 (current_state)))
      ;;              (if (keep_parsing) (parse_tag_recursive tag) tag))

      ;;             ((= (current_state) HTML_TAG_FRESH)
      ;;              (printf "Stopped in state HTML_TAG_FRESH\n")
      ;;              (set_current_state HTML_TAG_LABEL)
      ;;              (if (keep_parsing) (parse_tag_recursive tag) tag))
                   
      ;;             ((= (current_state) HTML_TAG_LABEL)
      ;;              (printf "Stopped in state HTML_TAG_LABEL\n")
      ;;              (label tag (toString (current_buffer)))
      ;;              (cond
      ;;               ((contains (upper (label tag))
      ;;                          (list (Str "LINK") (Str "BR") (Str "IMG") (Str "IMAGE") (Str "LI")))
      ;;                (printf "Marking tag %s as void\n" (cstring (label tag)))
      ;;                (set_void_element tag))
      ;;               (else
      ;;                (printf "Tag %s should not be void\n" (cstring (label tag)))
      ;;                (properties tag)))
      ;;              (skip_whitespace)
      ;;              (let ((c (next stream)))
      ;;                (cond ;; 2a
      ;;                 ((= c htmlForwardSlash)
      ;;                  (let ((d (peek stream)))
      ;;                    (cond ;; 3a
      ;;                     ((= d htmlCloseAngleBracket)
      ;;                      ;;(printf "Closed tag: <%s />\n" (cstring (label tag)))
      ;;                      (highlighter "red") (printf "%c" d) (highlighter "normal")
      ;;                      (next stream) ;; discard the ">" character
      ;;                      (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag))))) 
      ;;                     ((regex_match "\\w" (Str (cstring d))) (pop)
      ;;                      (printf "Ignored unexpected slash character in tag %s\n" (label tag))
      ;;                      (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_attribute_name_cond HTML_TAG_ATTRIBUTE_NAME))
      ;;                      (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                     (else ;; 3a
      ;;                      (printf "WTF? At 3a found %c in %s\n" d (label tag))
      ;;                      tag))))
      ;;                 ((= c htmlCloseAngleBracket)
      ;;                  (cond
      ;;                   ((void_element tag)
      ;;                    (printf "Closing void element %s\n" (cstring (label tag)))
      ;;                    (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag)))))
      ;;                   (else
      ;;                    (printf "Element %s should not be void, has property flag %x\n" (cstring (label tag)) (properties tag)) 
      ;;                    (pop)
      ;;                    (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_contents_cond HTML_TAG_CONTENT))
      ;;                    (if (keep_parsing) (parse_tag_recursive tag) tag))))
      ;;                 (else
      ;;                  (pop)
      ;;                  (push (HTMLParseContext tag char_reader (SSB (cstring c) 256) html_attribute_name_cond HTML_TAG_ATTRIBUTE_NAME))
      ;;                  (if (keep_parsing) (parse_tag_recursive tag) tag)))))
       
      ;;             ((= (current_state) HTML_TAG_ATTRIBUTE_NAME)
      ;;              (printf "Stopped in state HTML_TAG_ATTRIBUTE_NAME\n")
      ;;              (let ((attr:Pair{String*,String*}* (Pair (toString (current_buffer)) null))
      ;;                    (c (next stream)))
      ;;                (push_attribute tag attr)
      ;;                (cond ;; 2b
      ;;                 ((= c htmlDoubleQuote) (push (HTMLParseContext tag char_reader (current_buffer) html_literal_cond HTML_TAG_LITERAL))
      ;;                  (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                 ((= c htmlEquals) (pop)
      ;;                  (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_attribute_value_cond HTML_TAG_ATTRIBUTE_VALUE))
      ;;                  (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                 ((= c htmlForwardSlash)
      ;;                  (let ((d (peek stream)))
      ;;                    (cond ;; 3b
      ;;                     ((= d htmlCloseAngleBracket)
      ;;                      ;;(printf "Closed tag: <%s />\n" (cstring (label tag)))
      ;;                      (highlighter "red") (printf "%c" d) (highlighter "normal")
      ;;                      (next stream) ;; discard the ">" character
      ;;                      (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag)))))
      ;;                     ((regex_match "\\w" (Str (cstring d))) (pop)
      ;;                      (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_attribute_value_cond HTML_TAG_ATTRIBUTE_VALUE))
      ;;                      (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                     (else ;; 3b
      ;;                      (printf "WTF? At 3b found %c in %s\n" d (label tag))
      ;;                      tag))))
      ;;                 ((= c htmlCloseAngleBracket)
      ;;                  (cond
      ;;                   ((void_element tag)
      ;;                    (printf "Closing void element %s\n" (cstring (label tag)))
      ;;                    (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag)))))
      ;;                   (else
      ;;                    (printf "Element %s should not be void, has property flag %x\n" (cstring (label tag)) (properties tag)) 
      ;;                    (pop)
      ;;                    (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_contents_cond HTML_TAG_CONTENT))
      ;;                    (if (keep_parsing) (parse_tag_recursive tag) tag))))
      ;;                 (else ;; 2b
      ;;                  (printf "2b. Unexpected character %c in tag %s\n" c (label tag))
      ;;                  (next stream) (parse_tag_recursive tag)))))

      ;;             ((= (current_state) HTML_TAG_ATTRIBUTE_VALUE)
      ;;              (printf "Stopped in state HTML_TAG_ATTRIBUTE_VALUE\n")
      ;;              (let ((attr:Pair{String*,String*}* (pop_attribute tag))
      ;;                    (c (next stream)))
      ;;                (push_attribute tag (Pair (first attr) (toString (current_buffer))))
      ;;                (cond ;; 2c
      ;;                 ((= c htmlDoubleQuote) (push (HTMLParseContext tag char_reader (current_buffer) html_literal_cond HTML_TAG_LITERAL))
      ;;                  (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                 ((= c htmlForwardSlash)
      ;;                  (let ((d (peek stream)))
      ;;                    (cond ;; 3c
      ;;                     ((= d htmlCloseAngleBracket)
      ;;                      (pop)
      ;;                      ;; (printf "Closed tag: <%s />\n" (cstring (label tag)))
      ;;                      (highlighter "red") (printf "%c" d) (highlighter "normal")
      ;;                      (next stream) ;; discard the ">" character
      ;;                      (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag)))))
      ;;                     ((regex_match "\\w" (Str (cstring d)))
      ;;                      (pop)
      ;;                      (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_attribute_name_cond HTML_TAG_ATTRIBUTE_NAME))
      ;;                      (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                     (else ;; 3c
      ;;                      (printf "WTF? At 3b found %c in %s\n" d (label tag))
      ;;                      tag))))
      ;;                 ((= c htmlCloseAngleBracket)
      ;;                  (cond
      ;;                   ((void_element tag)
      ;;                    (printf "Closing void element %s\n" (cstring (label tag)))
      ;;                    (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag)))))
      ;;                   (else
      ;;                    (printf "Element %s should not be void, has property flag %x\n" (cstring (label tag)) (properties tag)) 
      ;;                    (pop)
      ;;                    (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_contents_cond HTML_TAG_CONTENT))
      ;;                    (if (keep_parsing) (parse_tag_recursive tag) tag))))
      ;;                 ((= c htmlSpace)
      ;;                  (pop)
      ;;                  (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_attribute_name_cond HTML_TAG_ATTRIBUTE_NAME))
      ;;                  (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                 (else ;; 2c
      ;;                  (printf "2c. Unexpected character %c in tag %s\n" c (label tag))
      ;;                  (next stream) (parse_tag_recursive tag)))))

      ;;             ((= (current_state) HTML_TAG_CONTENT)
      ;;              (printf "Stopped in state HTML_TAG_CONTENT\n")
      ;;              (if (end_of_stream stream) tag
      ;;                  (let ((c (next stream)))
      ;;                    (cond ;; 2d
      ;;                     ((= c htmlDoubleQuote) (push (HTMLParseContext tag char_reader (current_buffer) html_literal_cond HTML_TAG_LITERAL))
      ;;                      (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                     ((= c htmlOpenAngleBracket)
      ;;                      (printf "Found opening angle bracket, now disambiguating by peeking at next character: ")
      ;;                      (let ((d (peek stream)))
      ;;                        (printf "%c\n" d)
      ;;                        (cond ;; 3d 
      ;;                         ((= d htmlForwardSlash) ;; this is an ending tag so finalise the content
      ;;                          (contents tag (current_buffer))
      ;;                          (pop)
      ;;                          (highlighter "red") (printf "%c" d) (highlighter "normal")
      ;;                          (next stream) ;; discard slash
      ;;                          (push (HTMLParseContext tag char_reader (StringStreamBuffer_c 256) html_end_label_cond HTML_TAG_END_LABEL))
      ;;                          (if (keep_parsing) (parse_tag_recursive tag) tag))
      ;;                         (else ;; 3d  --  a child is born!
      ;;                          (printf "A child is born\n") 
      ;;                          (let ((child:HTMLTag* (HTMLTag (String "tba") tag null null (StringStreamBuffer_c 256) (binary "00000000"))))
      ;;                            (add_child tag child)
      ;;                            (push (HTMLParseContext child char_reader (StringStreamBuffer_c 256) html_label_cond HTML_TAG_FRESH))
      ;;                            (parse_tag_recursive child)
      ;;                            (if (keep_parsing) (parse_tag_recursive tag) tag))))))
      ;;                     (else ;; 2d  --  may have returned from parsing a child tag
      ;;                      ;; (printf "If you see this message, check out what is going on\n")
      ;;                      (if (keep_parsing) (parse_tag_recursive tag) tag))))))

      ;;             ((= (current_state) HTML_TAG_END_LABEL)
      ;;              (printf "Stopped in state HTML_END_LABEL\n")
      ;;              (cond ;; 2e1 
      ;;               ((equal (label tag) (toString (current_buffer)))
      ;;                (cond ;; 3e1
      ;;                 ((end_of_stream stream) tag)
      ;;                 (else ;; 3e1
      ;;                  (skip_whitespace)
      ;;                  (let ((c (next stream)))
      ;;                    (cond ;; 4e1
      ;;                     ((= c htmlCloseAngleBracket)
      ;;                      ;; (printf "Closed tag: <%s />\n" (cstring (label tag)))
      ;;                      (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag)))))
      ;;                     (else ;; 4e1
      ;;                      (printf "4e1. Unexpected character %c in tag %s\n" c (label tag))
      ;;                      (cond ((null? (parent tag)) tag) (else (pop) (parse_tag_recursive (parent tag))))))))))
      ;;               (else ;; 2e1
      ;;                (printf "Closing tag mismatch: Found </%s> whilst parsing content of <%s>\n" (cstring (current_buffer)) (cstring (label tag)))
      ;;                (let* ((match_loop:[HTMLTag*,HTMLTag*,String*]*
      ;;                        (lambda (tag name)
      ;;                          (printf "Called match loop with context stack at address %p" (@ context_stack_ref 0))
      ;;                          tag))
      ;;                ;;           (if (non-null tag) (printf " with Tag: %s" (cstring (label tag))))
      ;;                ;;           (if (non-null tag) (printf " with Name: %s" (cstring name)))
      ;;                ;;           (printf "\n")
      ;;                ;;           (cond ;; 3e2
      ;;                ;;            ((null? tag) (printf "debug1\n") null)
      ;;                ;;           (else (printf "debug2\n") ;; 3e2
      ;;                ;;            (cond ;; 4e2
      ;;                ;;             ((equal name (label tag)) tag)
      ;;                ;;             (else (printf "debug3\n") ;; 4e2
      ;;                ;;              (cond ;; 5e1
      ;;                ;;               (#f   ;;(empty context_stack)
      ;;                ;;                (printf "debug3b\n") tag)
      ;;                ;;               (else
      ;;                ;;                (printf "debug4\n") ;; 5e1
      ;;                ;;                (pop)
      ;;                ;;                (printf "debug5\n")
      ;;                ;;                (cond ;; 6e1
      ;;                ;;                 ((null? (current_tag)) null)
      ;;                ;;                 (else (printf "debug6\n") ;; 6e1
      ;;                ;;                  (match_loop (current_tag) name)))))))))))
      ;;                       (matching_tag (match_loop tag (toString (current_buffer)))))
      ;;                  (printf "Matching tag is %p\n" (cast matching_tag i8*))
      ;;                  ;; (cond ;; 3e3
      ;;                  ;;  ((null? matching_tag)
      ;;                  ;;   (printf "Badly formed HTML. No matching start tag found for close tag %s\n" (cstring (label tag)))
      ;;                  ;;   tag)
      ;;                  ;;  (else ;; 3e3
      ;;                  ;;   (printf "Found matching tag: %s\n" (cstring (label matching_tag)))
      ;;                  ;;   (cond ;; 4e3
      ;;                  ;;    ((null? (current_buffer))
      ;;                  ;;     (printf "Something went wrong, couldn't close down matched tag %s\n" (cstring (label matching_tag)))
      ;;                  ;;     matching_tag)
      ;;                  ;;    (else ;; 4e3
      ;;                  ;;     (contents matching_tag (current_buffer))
      ;;                  ;;     (cond ((null? (parent matching_tag)) matching_tag) (else (pop) (parse_tag_recursive (parent matching_tag)))))))))
      ;;                  tag))))
      ;;             (else (printf "Must have forgotten something.\n") tag)))))))
      ;; (let ((doc:HTMLTag* (burnin_loop)))
      ;;   ;; (println "\n\n Starting parsing from tag: ")
      ;;   ;; (print doc)
      ;;   (pset! context_stack_ref 0 null)
      ;;   (push (HTMLParseContext doc char_reader (StringStreamBuffer_c 256) html_content_cond HTML_TAG_CONTENT))
      ;;   (if (keep_parsing)
      ;;       (parse_tag_recursive doc)
      ;;       doc)
      ;;   ))))


        
(set! *xtmlib-ybot-parser-loaded* #t)
