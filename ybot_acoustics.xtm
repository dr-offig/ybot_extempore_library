(sys:load-preload-check 'ybot_acoustics)
(define *xtmlib-ybot_acoustics-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/external/gl/gl-objects.xtm")
 (sys:load "libs/external/glfw3.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/external/gl/gl-objects.xtm")
 (sys:load "libs/external/glfw3.xtm"))

;; this function from gl-objects is over-ridden here to suppress logging output
(bind-func VBO_create
  (lambda (buf:float* buflen)
    (let ((vbo:VBO* (halloc))
          (id:GLuint* (salloc)))
      (glGenBuffers 1 id)
      (gl_print_error "Error creating VBO")
      (tfill! vbo
              (pref id 0)
              GL_FLOAT
              (* buflen 4) ;; sizeof(float)
              (cast buf GLvoid*))
      (glBindBuffer GL_ARRAY_BUFFER (VBO_id vbo))
      (glBufferData GL_ARRAY_BUFFER (VBO_size vbo) (VBO_data vbo) GL_STREAM_DRAW)
      (gl_print_error "Error setting VBO data")
      vbo)))


;; this actually creates the window
;; (bind-val window GLFWwindow*
;;   (begin
;;     (glfwSetErrorCallback (convert (get_native_fptr glfw_error_callback)))
;;     (glfw_init_and_create_fullscreen_interaction_window)))
(bind-val window GLFWwindow*
  (begin
    (glfwSetErrorCallback (convert (get_native_fptr glfw_error_callback)))
    (glfw_init_and_create_interaction_window 1000 1000)))


;; Once the window is created we can query its properties
(bind-val pixel_ratio float (glfw_get_pixel_ratio window))
(bind-val width float (glfw_get_window_width window))
(bind-val height float (glfw_get_window_height window))
(bind-val cx float (/ width 2.0:float))
(bind-val cy float (/ height 2.0:float))

;; this is the video frame-rate
(bind-val FRAMERATE float 60.)
(bind-val FRAMEDURATION float (/ 1. FRAMERATE))
(bind-val FRAMEDELTA float (* SAMPLERATE (/ 1. FRAMERATE)))
(bind-func frame_rate:[float,float]*
  (lambda (rate)
    (set! FRAMERATE rate)
    (set! FRAMEDURATION (/ 1. FRAMERATE))
    (set! FRAMEDELTA (* SAMPLERATE (/ 1. FRAMERATE)))
    rate))

;; Setup a vertex array - one vertex per monopoke
(bind-val num_pokes i64 7)
(bind-val mp_vert_data float*)
(bind-val mp_vbo VBO*)
(bind-val mp_vao VAO*)
(bind-val mp_prog ShaderProgram)
(bind-val speaker_spacing float 0.1)
(bind-val speaker_radius float 0.5)

(bind-func initialise_n_shaders
  (lambda (n:i64)
    (set! num_pokes n)
    (set! speaker_spacing (/ 1.0:float (i64tof num_pokes)))
    (set! speaker_radius (* 0.5:float speaker_spacing))
    (set! mp_prog
         (ShaderProgram_create
          (sys_slurp_file "/Users/ybot/Documents/code/ybot/ybot_extempore_library/monopoke.vert")
          (sys_slurp_file "/Users/ybot/Documents/code/ybot/ybot_extempore_library/monopoke.frag")))
    (let ((tmp:float* (alloc (* 5 num_pokes))) (i:i64 0))
      (set! mp_vert_data tmp)
      (pfill! mp_vert_data
              0.0 0.0 0.0  -1.0 0.0)
      (dotimes (i (/ (- num_pokes 1) 2))
        (pfill! (pref-ptr mp_vert_data (+ 5 (* i 10)))
            ;; position (x,y,depth)  radiator (x,y)
            0.0  0.0  0.0             -1.0  (* (i64tof (+ i 1)) speaker_spacing)
            0.0  0.0  0.0             -1.0  (* -1.0 (* (i64tof (+ i 1)) speaker_spacing))
            )))
    ;;(set! mp_vbo (VBO_create (aref-ptr mp_vert_data 0) 5))
    (set! mp_vbo (VBO_create mp_vert_data (* 5 num_pokes)))
    (set! mp_vao (VAO_create))
    (VAO_bind_attribute mp_vao mp_vbo 0 3 5 0) ;; position
    (VAO_bind_attribute mp_vao mp_vbo 1 2 5 3) ;; radiator
    void))

(initialise_n_shaders 7)
;($ (run_oscilloscope #f))

($ (glGet GL_POINT_SIZE))

(bind-func draw_frame:[void]*
  (let ((timeloc (glGetUniformLocation mp_prog "ct"))
        (radiusloc (glGetUniformLocation mp_prog "radius"))
        (screenWidthLoc (glGetUniformLocation mp_prog "screenWidth"))
        (screenHeightLoc (glGetUniformLocation mp_prog "screenHeight"))
        (num_pokesLoc (glGetUniformLocation mp_prog "num_pokes"))
        (a:float speaker_radius) (rate:float (convert .001)) (ct:float (convert 0.0)))
    (glEnable GL_BLEND)
    (glBlendFunc GL_ONE GL_ONE)
    (glClearColor 0.0 0.0 1.0 1.0)
    (glDisable GL_PROGRAM_POINT_SIZE)
    (glPointSize 1000.0)
    (lambda ()
      ;; update clock
      (set! ct (modulo (+ ct rate) 1.0)) 

      ;; clear the framebuffer's colour and depth buffers
      (glClear (bor GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))

      ;; render the monopokes
      (glUseProgram mp_prog)
      (glUniform1i num_pokesLoc (i64toi32 num_pokes))
      (glUniform1f timeloc (convert ct))
      (glUniform1f radiusloc (convert speaker_radius))
      (glUniform1f screenWidthLoc (convert width))
      (glUniform1f screenHeightLoc (convert height))
      (glPointSize (convert height))
      (VAO_bind_and_draw_arrays mp_vao GL_POINTS 0 (i64toi32 num_pokes))

      ;; thats all folks
      void)))


(bind-func draw_loop
  (let ((go:bool #t) (initialised:bool #f))
    (lambda (time:i64)
      (cond
       (go
        (draw_frame)
        (glfwPollEvents)
        (glfwSwapBuffers window)
        (let ((next_time (+ time (convert FRAMEDELTA))))
          (callback next_time draw_loop next_time)
          void))
       (else void)))))

(bind-func run_oscilloscope:[void,bool]*
  (lambda (flag:bool)
    (cond
     (flag
      (cond
       ((draw_loop.go:bool)
        (cond
         ((draw_loop.initialised:bool)
          void)
         (else
          (draw_loop.initialised:bool #t)
          (draw_loop (now)))))
       (else
        (draw_loop.go:bool #t)
        (draw_loop (now))
        void)))
     (else
      (draw_loop.go:bool #f)
      void))))


($ (run_oscilloscope #t))

(define *xtmlib-ybot_oscilloscope-loaded* #t)
