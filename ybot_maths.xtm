;; Include guard
(if (and (defined? '*xtmlib-ybot-math-loaded*) *xtmlib-ybot-math-loaded*)
    (sys:load-escape "ybot_math library already loaded"))
(define *xtmlib-ybot-math-loaded* #f)

(bind-func at:[!a,!b]*
  (lambda (ptr)
    (pref ptr 0)))

(bind-func pcopy!:[void,!a,!a,i64]*
  (lambda (target:!a source:!a n:i64)
    (let ((i:i64 0)
          (dotimes (i n)
            (pset! target i (pref source i))))
      void)))

(bind-func lerp:[!a,!a,!a,!a]*
           (lambda (a b t)
             (+ (* t b) (* (- 1.0 t) a))))

(bind-func mod_i:[i64,i64,i64]*
  (lambda (x:i64 b:i64)
    (let ((t:i64 (% x b)))
      (if (>= t 0) t (+ t b)))))

(bind-func mod_s:[SAMPLE,SAMPLE,SAMPLE]*
  (lambda (x:SAMPLE b:SAMPLE)
    (let ((t:SAMPLE (% x b)))
      (if (>= t (convert 0)) t (+ t b)))))

(bind-poly mod mod_i)
(bind-poly mod mod_s)

(bind-func mod_inc:[!a,!a,!a]*
  (lambda (n base)
    (mod (+ n 1) base)))

(bind-func dist_f:[float,float,float]*
  (lambda (x:float y:float)
    (fabs (- x y))))

(bind-func dist_d:[double,double,double]*
  (lambda (x y)
    (fabs (- x y))))

(bind-func dist_i32:[i32,i32,i32]*
  (lambda (x y)
    (abs (- x y))))

(bind-func dist_i64:[i64,i64,i64]*
  (lambda (x y)
    (i32toi64 (abs (i64toi32 (- x y))))))

(bind-poly dist dist_f)
(bind-poly dist dist_d)
(bind-poly dist dist_i32)
(bind-poly dist dist_i64)


;; COLUMN MAJOR Matrix Library
(bind-type Vector <!a,i64>)
(bind-type Matrix <!a,i64,i64>)

;(bind-func print_matrix:[void,Matrix*]*
;  (lambda (m:Matrix*)
;    (mprint (tref m 0) (tref m 1) (tref m 2) (i64toi1 1))
;    void))

;(bind-func print:[void,Matrix*]*
;  (lambda (m)
;    (mprint (tref m 0) (tref m 1) (tref m 2) (i64toi1 0))
;    void))

(bind-func print_serial:[void,Matrix*]*
  (lambda (m)
    (let ((cc:i64 0)
          (s:i64 (* (tref m 1) (tref m 2))))
      (dotimes (cc s)
        (print (pref (tref m 0) cc))
        (print " ")))
    void))


(bind-func Identity:[Matrix*,i64]*
  (lambda (size)
    (let* ((data (zalloc (* size size)))
           (output (Matrix data size size))
           (i:i64 0) (j:i64 0) (cc:i64 0))
      (dotimes (j size)
        (dotimes (i size)
          (if (= j i)
              (pset! data cc (convert 1))
              (pset! data cc (convert 0)))
          (set! cc (+ cc 1))))
      output)))
              

(bind-func Matrix_of_Ones:[Matrix*,i64,i64]*
  (lambda (rows cols)
    (let* ((data (zalloc (* rows cols)))
           (output (Matrix data rows cols))
           (i:i64 0) (j:i64 0) (cc:i64 0))
      (dotimes (j cols)
        (dotimes (i rows)
          (pset! data cc (convert 1))
          (set! cc (+ cc 1))))
      output)))

(bind-func Matrix_of_Zeros:[Matrix*,i64,i64]*
  (lambda (rows cols)
    (let* ((data (zalloc (* rows cols)))
           (output (Matrix data rows cols))
           (i:i64 0) (j:i64 0) (cc:i64 0))
      (dotimes (j cols)
        (dotimes (i rows)
          (pset! data cc (convert 0))
          (set! cc (+ cc 1))))
      output)))

(bind-func ConstantMatrix:[Matrix*,i64,i64,!a]*
  (lambda (rows cols val)
    (let* ((data (zalloc (* rows cols)))
           (output (Matrix data rows cols))
           (i:i64 0) (j:i64 0) (cc:i64 0))
      (dotimes (j cols)
        (dotimes (i rows)
          (pset! data cc (convert val))
          (set! cc (+ cc 1))))
      output)))

(bind-func EnuMatrix:[Matrix*,i64,i64]*
  (lambda (rows cols)
    (let* ((data (zalloc (* rows cols)))
           (output (Matrix data rows cols))
           (i:i64 0) (j:i64 0) (cc:i64 0)) 
      (dotimes (j cols)
        (dotimes (i rows)
          (pset! data cc (convert cc))
          (set! cc (+ cc 1))))
      output)))


(bind-func EnuCols:[Matrix*,i64,i64]*
  (lambda (rows cols)
    (let* ((data (zalloc (* rows cols)))
           (output (Matrix data rows cols))
           (i:i64 0) (j:i64 0) (cc:i64 0)) 
      (dotimes (j cols)
        (dotimes (i rows)
          (pset! data cc (convert j))
          (set! cc (+ cc 1))))
      output)))


(bind-func EnuRows:[Matrix*,i64,i64]*
  (lambda (rows cols)
    (let* ((data (zalloc (* rows cols)))
           (output (Matrix data rows cols))
           (i:i64 0) (j:i64 0) (cc:i64 0)) 
      (dotimes (j cols)
        (dotimes (i rows)
          (pset! data cc (convert i))
          (set! cc (+ cc 1))))
      output)))


(bind-func Matrix_rows:[i64,Matrix*]*
  (lambda (m)
    (tref m 1)))

(bind-func Matrix_cols:[i64,Matrix*]*
  (lambda (m)
    (tref m 2)))

(bind-func Matrix_data:[!a,Matrix*]*
  (lambda (m)
    (tref m 0)))

(bind-func mref:[!a,Matrix*,i64,i64]*
  (lambda (m i j)
    (pref (tref m 0) (+ (* j (tref m 1)) i))))

(bind-func mset:[void,Matrix*,i64,i64,!a]*
  (lambda (m i j val)
    (pset! (tref m 0) (+ (* j (tref m 1)) i) val)
    void))
  

(bind-func print:[void,Matrix*]*
  (lambda (m)
    (let ((rows:i64 (Matrix_rows m))
          (cols:i64 (Matrix_cols m))
          (i:i64 0) (j:i64 0))
      (dotimes (i rows)
        (printf "[")
        (dotimes (j cols)
          (print (mref m i j))
          (if (< j (- cols 1)) (printf " ")))
        (printf "]\n")))
    void))



;(bind-func MatrixMult_inPlace:[i1,Matrix*,Matrix*,Matrix*]*
;  (lambda (a b c)
;    (if (= (Matrix_cols a) (Matrix_rows b))
;        (begin
;          (mmul
;           (Matrix_data a) (Matrix_rows a) (Matrix_cols a)
;           (Matrix_data b) (Matrix_rows b) (Matrix_cols b)
;           (Matrix_data c))
;          (i64toi1 1))
;        (i64toi1 0))))
    

(bind-func MatrixMult_inPlace:[i1,Matrix*,Matrix*,Matrix*]*
  (lambda (m n p)
    (let ((a (tref m 0)) (ra (tref m 1)) (ca (tref m 2))
          (b (tref n 0)) (rb (tref n 1)) (cb (tref n 2))
          (d (tref p 0)) (rd (tref p 1)) (cd (tref p 2)))
      (if (and (= ca rb) (= ra rd) (= cb cd))
          (let ((id:i64 0) (jd:i64 0))
            (dotimes (id rd)
              (dotimes (jd cd)
                (let ((k:i64 0) (v:!a (convert 0.0)))
                  (dotimes (k ca)
                    (set! v (+ v (* (mref m id k) (mref n k jd)))))
                  (mset p id jd v))))
            (i64toi1 1))
          (i64toi1 0)))))


(set! *xtmlib-ybot-math-loaded* #t)
